---
title: "Schaefer Workflow"
author: "Iris Foxfoot"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(terra) #r package for raster data
library(tidyterra) #for dealing with rasters as dataframes (used when plotting)
library(ggplot2) #for plotting 
library(gganimate) #for animated plots
```

# Introduction to the Schaefer Surplus Production Model

The Schaefer model is a simple surplus production model, used to determine how much fish is left after fishing mortality has occurred. 

The Schaefer model equation for a discrete timestep is as follows:


$$B_{t+1} = B_t + r B_t \left(1 - \frac{B_t}{K} \right) - C_t$$

- $B_t$ represents biomass at time $t$, any biomass unit can be used as long as units are used consistently throughout the model.

- $r$ represents the populationâ€™s intrinsic growth rate, it is a dimensionless ratio. 

- $K$ represents the carrying capacity of the population, or total biomass that can be supported.

- $Ct$ represents catch during time $t$, it is the total amount of biomass removed from the system.

- $B_0$ is the initial biomass, which can also be used to represent $K$ if the system is in a baseline state.

# Running the Model at a Single Point

The following R function can be used to calculate biomass at time $t$ using the Schaefer Surplus Production Model:

```{r}
SSPM <- function(Binit, r, K, C, timestep) {
  #creating an empty list to hold biomass values at each timestep
  biomass <- numeric(length = timestep)
  #setting the first biomass value to be initial biomass
  biomass[1] <- Binit
  #creating a loop to run sspm
  for (t in 2:timestep){
    biomass[t] <- biomass[t-1] + r * biomass[t-1] * (1 - (biomass[t-1]/K)) - C[t-1]
  }
  #returning list of biomass values
  return(biomass)
}
```

Now, we can run the model and see how biomass changes over time

```{r}
Binit <- 1000 #initial biomass
r <- 0.75 #intrinsic growth rate
K <- 1000 #carrying capacity same as initial biomass
timestep <- 120 #120 timesteps
C <- numeric() #C is a numeric list

#now I am saying every 12 timesteps C is 450 and at all other timesteps it is 0
for (i in 1:timestep){C[i] = ifelse (i %% 12 == 0, 450, 0)}

#now run the model
biomass <- SSPM(Binit = Binit, r = r, K = K, C = C, timestep = timestep)

#now plot biomass
plot(y = biomass, x = 1:timestep, type = "line", 
     main = "Biomass over time with periodic mortality events")
```

We can also introduce stochasticity into the model by varying $r$. This could represent freshwater inflows, storm events, or other variations in environmental conditions that influence recovery time.

```{r}
#redoing the function so a list value is accepted for R
SSPM_variable_r <- function(Binit, r, K, C, timestep) {
  #creating an empty list to hold biomass values at each timestep
  biomass <- numeric(length = timestep)
  #setting the first biomass value to be initial biomass
  biomass[1] <- Binit
  #creating a loop to run sspm
  for (t in 2:timestep){
    biomass[t] <- biomass[t-1] + r[t-1] * biomass[t-1] * (1 - (biomass[t-1]/K)) - C[t-1]
  }
  #returning list of biomass values
  return(biomass)
}

#create list of random r values
r <- runif(timestep, 0, 1)

#run the model
biomass <- SSPM_variable_r(Binit = Binit, r = r, K = K, C = C, timestep = timestep)

#plot biomass
plot(y = biomass, x = 1:timestep, type = "line",
     main = "Biomass over time with periodic mortality events and varying r")
```

# Running the Model Accross a Raster

First we will create a raster containing initial biomass data to use as input data.

```{r}
#this will generate initial biomass data (I will also use this for K)

#create empty biomass raster
biomass_raster <- rast(nrows = 10, ncols = 10)

#fill with random values between 0 and 1000
values(biomass_raster) <- runif(ncell(biomass_raster), min = 0, max = 1000)

#name layer
names(biomass_raster) <- "Bt_init" 

#plot it
plot(biomass_raster,
     main = "Initial Biomass Raster")
```


Then I will run the function across the raster, using the raster values as the initial biomass and $K$.

```{r}
#function to apply to each raster cell
biomass_raster_fun <- function(Bt, r, K, Ct){
  Bt_1 = Bt + r * Bt * (1 - (Bt / K)) - Ct
  return(Bt_1)
}

#setting up time step iteration
time_steps <- 120

#setting up C
C <- numeric() 

#now I am saying every 12 timesteps C is 0.5 and at all other timesteps it is 0
for (i in 1:time_steps){C[i] = ifelse (i %% 12 == 0, 0.5, 0)}

#creating raster stack to hold results
output_stack <- rast()

#adding biomass raster to the stack
output_stack <- c(output_stack, biomass_raster)

#loop through timestep and apply function
for (t in 1:time_steps) {
  #applying function to raster layer t, where v is the value in each raster cell
  bt_raster <- app(output_stack[[t]], fun = function(v) 
    #note that C is multiplied by biomass now, so c represents proportion of biomass removed
    biomass_raster_fun(Bt = v, r = 0.75, K = v, Ct = v *C[t]))
  #naming the output raster
  names(bt_raster) <- paste0("Bt_", t)
  #adding output raster to the raster stack
  output_stack <- c(output_stack, bt_raster)  
}

plot(output_stack[[1:20]])
```

Next I will make an animated plot so we can see the changes

```{r}
# Convert to a data frame with coordinates
df <- as.data.frame(output_stack, xy = TRUE)

# Reshape from wide to long format
df_long <- df %>%
  pivot_longer(cols = starts_with("Bt_"), 
               names_to = "Layer", 
               values_to = "Value")


p <- ggplot(df_long, aes(x = x, y = y, fill = Value)) +
  geom_raster() +
  #scale_fill_viridis_c() +
  coord_equal() +
  labs(title = 'Layer: {closest_state}') +
  theme_minimal() +
  transition_states(Layer, transition_length = 2, state_length = 1)

# Save animation
animate(p, fps = 2, width = 800, height = 600)
#anim_save("raster_stack_animation.gif")


```

To Do
- work on animation
- Demo using a raster layer for C
- make some notes about data sources for inputs for Binit/K, r, and C


